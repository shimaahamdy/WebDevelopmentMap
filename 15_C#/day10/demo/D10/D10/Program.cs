using D10;
using System.Text.RegularExpressions;
using static D10.ListGenerators;


#region Implicit Typed Local Variable

///Implicit Typed Local Variable
//double D = 13.5;

//Console.WriteLine(D.GetType());

//D = "Hello";

//var D = 13.5;

//Console.WriteLine(D.GetType());

//D = "Hello"; 
#endregion

#region Anonymous Type
////Employee E1 = new Employee() { Id = 1, Name = "Ahmed Ali", Salary = 4000 };

////var E2 = new Employee() { Id = 2, Name = "Sally Sayed", Salary = 7000 };

/////Anonymous Type
/////Class will be Generated by Compiler based on Properties Name and Data type
/////Class will contain overloaded ToString , Equals (based on value ), GetHashcode (based on Value)
/////Generated class will be Immutable Data type , E.ID is getter only , is read only
//var E1 = new { Id = 2, Name = "Sally Sayed", Salary = 7000M };
//Console.WriteLine(E1.GetType().Name);
//Console.WriteLine(E1.GetType());
//Console.WriteLine(E1);

//Console.WriteLine(E1.Id);
////E1.Id = 101;


//var E2 = new { Id = 3, Name = "Mohamed Ali", Salary = 8000M };
//Console.WriteLine(E2.GetType().Name);

////var E3 = new { Name = "Mohamed Ali", Id = 3,  Salary = 8000M };
////Console.WriteLine(E3.GetType().Name);

//var E3 = new { Id = 2, Name = "Sally Sayed", Salary = 7000M };

//if ( E1.Equals (E3) )
//    Console.WriteLine("Value EQ");
//else
//    Console.WriteLine("Identity EQ");

//Console.WriteLine(E1.GetHashCode());
//Console.WriteLine(E3.GetHashCode());

////object E4 = new { Id = 2, Name = "Sally Sayed", Salary = 7000M };
////E4. 
#endregion

#region Extension Method
//int X = 12345;

//Console.WriteLine(Int32Extensions.Mirror(X));
//Console.WriteLine(X.Mirror()); 
#endregion

List<int> Lst = new() { 1, 2, 3, 4, 5, 6,7, 8, 9, 10 };

#region LINQ Where EX01
/////Where LINQ Operator


/////V1.0 as Static Method in Static Class
//var Result = Enumerable.Where(Lst, i => i % 2 == 1);

/////V2.0 as Extension Method
/////Fluent Syntax
//Result = Lst.Where(i => i % 2 == 1);


/////V3. Query Expression
/////Valid only in Subset of LINQ Operators (12 Operator Only)
//Result = from i in Lst ///i is Range Variable : representing each and every element in Input Sequence
//         where i % 2 == 1
//         select i;
/////Query Expression must end with Select or Groupby


/////All 3 versions will Compile to the EXACT IL as V1.0

//Console.WriteLine(Result.GetType());
//Console.WriteLine(Result.GetType().Name);

//foreach (var item in Result)
//{
//    Console.WriteLine(item);
//} 
#endregion


#region Deferred Execution Operators - Where
////var Result = Lst.Where(i => i % 2 == 1);

//var Result = from i in Lst
//             where i % 2 == 1
//             select i;

//Lst.AddRange(new int[] { 11, 12, 13, 14, 15 });


//foreach (var item in Result)
//{
//    Console.WriteLine(item);
//}

//Lst.Remove(1);
//Lst.Remove(3);
//Lst.AddRange(new int[] { 16, 17, 18, 19 });


//Console.WriteLine("Second foreach");
//foreach (var item in Result)
//{
//    Console.WriteLine(item);
//} 
#endregion

#region Immediate Operator - Casting Operator ToList
//var Result = Lst.Where(i => i % 2 == 1).ToList();
//Console.WriteLine(Result.GetType());
////var Result = (from i in Lst
////             where i % 2 == 1
////             select i).ToList();

//Lst.AddRange(new int[] { 11, 12, 13, 14, 15 });


//foreach (var item in Result)
//{
//    Console.WriteLine(item);
//}

//Lst.Remove(1);
//Lst.Remove(3);
//Lst.AddRange(new int[] { 16, 17, 18, 19 });


//Console.WriteLine("Second foreach");
//foreach (var item in Result)
//{
//    Console.WriteLine(item);
//}



#endregion


#region Indexed Where

///only in Fluent Sytax not Query Expression
///i representing index of element in input Sequence
//var Result = ProductList.Where((P, i) => P.UnitsInStock == 0 && i <= 10);

#endregion

#region Transformation - Select 
//var Result = ProductList.Select(P => P.ProductName);

//Result = ProductList.Where(P => P.UnitsInStock == 0).Select(P => P.ProductName);


//Result = from P in ProductList
//         where P.UnitsInStock == 0
//         select P.ProductName;



//var Result = ProductList.Where(P => P.UnitsInStock == 0)
//                        .Select(P => new { Name = P.ProductName , P.Category});


//Result = from P in ProductList
//         where P.UnitsInStock == 0
//         select new { Name = P.ProductName, P.Category };

///Indexed Select , Only in Fluent Syntax

//var Result = ProductList.Where(P => P.UnitsInStock == 0).Select((P, i) => new { Index = i, P.ProductName });

#endregion

#region Ordering Operators

//var Result = ProductList.OrderBy(P => P.UnitPrice);


//Result = from P in ProductList
//         orderby P.UnitPrice
//         select P;

//Result = ProductList.OrderByDescending(P => P.UnitPrice);


//Result = from P in ProductList
//         orderby P.UnitPrice descending
//         select P;

//Result = ProductList.OrderByDescending(P => P.UnitPrice)
//                        .ThenBy (P => P.UnitsInStock);


//Result = from P in ProductList
//         orderby P.UnitPrice descending , P.UnitsInStock
//         select P;


//Result = ProductList.OrderByDescending(P => P.UnitPrice)
//                        .ThenByDescending(P => P.UnitsInStock);


//Result = from P in ProductList
//         orderby P.UnitPrice descending, P.UnitsInStock descending
//         select P;

//var Result = ProductList.OrderBy(P => P , );

#endregion

#region Natural Ordering Operators
//var Result = ProductList.Take(5);
/////take first 5 elements into Output Seq , Skip the rest

//Result = ProductList.Skip(50);
///// Skip first n Elements , Take the rest into Output Seq

//Result = ProductList.TakeLast(5);

//Result = ProductList.SkipLast(50);

///Paging
//for (int i = 0; i < (ProductList.Count / 10) + 1; i++)
//{
//    var Result = ProductList.Skip(10 * i).Take(10);

//    foreach (var item in Result)
//    {
//        Console.WriteLine(item);
//    }

//    Console.ReadLine();
//    Console.Clear();
//}

//var Result = ProductList.TakeWhile(P => P.UnitsInStock > 0);
/////Take elements into Output seq as long as Predicate return true , skip at first predicate returning false

//Result = ProductList.SkipWhile(P => P.UnitsInStock != 0);
///// Skip Elements as long as Predicate return true , at first Predicate returnning False Take all the remaining Elements

#endregion

#region Single Element Operators - Immediate Execution

//var Result = ProductList.First();

//Result = ProductList.Last();

//Result = ProductList.First(P => P.UnitsInStock == 0);

//Result = ProductList.Last(P => P.UnitsInStock == 0);


//List<Product> DiscountedProducts = new();

////Result = DiscountedProducts.First();
/////if no elements exists in the input Seq , Throw exception

////Result = ProductList.First(P => P.UnitPrice > 500);
/////if no elements matching Predicate in the input Seq , Throw exception


//Result = DiscountedProducts.FirstOrDefault();
//Result = DiscountedProducts.LastOrDefault();

/////if no elements exists in the input Seq ,return Defualt value (null) no exceptions will be thrown

//Result = ProductList.FirstOrDefault(P => P.UnitPrice > 500);
//Result = ProductList.LastOrDefault(P => P.UnitPrice > 500);
/////if no elements matching Predicate in the input Seq , return Defualt value (null) no exceptions will be thrown

//Result = ProductList.ElementAt(^2); ///Index
//Result = ProductList.ElementAt(2);

////Result = ProductList.ElementAt(80);// UnSafe

//Result = ProductList.ElementAtOrDefault(80);
///// return defualt (Null) in case no element Exists in this Index


//DiscountedProducts.Add(ProductList.First());

//Result = DiscountedProducts.Single();
/////return Single Element in Input Seq 
/////if Zero Elements in Input Seq , Throw Exception
/////if More than one Element in Input Seq , Throw Exception

//int n = 17;

//Result = ProductList.Single(P => P.ProductID == n);
/////return Single Element in Input Seq Matching Predicate
/////if Zero Elements Matching Predicate in Input Seq , Throw Exception
/////if More than one Element Matching Predicate in Input Seq , Throw Exception

//DiscountedProducts.Clear();

//Result = DiscountedProducts.SingleOrDefault();
/////return Single Element in Input Seq 
/////if Zero Elements in Input Seq , return Default (null) no Exception
/////if More than one Element in Input Seq , Throw Exception

//Result = ProductList.SingleOrDefault(P => P.ProductID == 80);
/////return Single Element in Input Seq Matching Predicate
/////if Zero Elements Matching Predicate in Input Seq , return Default , no Exception
/////if More than one Element Matching Predicate in Input Seq , Throw Exception


////Result = ProductList.SingleOrDefault(P => P.ProductID >= 8);///Exception


//Console.WriteLine(Result?.ProductName??"NA");
#endregion

#region Aggregate Operators - Immediate Execution

//Console.WriteLine( ProductList.Count() );

//Console.WriteLine(ProductList.Count(P=>P.UnitsInStock ==0));

//Console.WriteLine(ProductList.Min());
//Console.WriteLine(ProductList.Max()); //return element , select using Default Comparer

//Console.WriteLine(ProductList.Min (P=> P.UnitPrice)); ///return Min UnitPrice

////var Rst = (from P in ProductList
////          where P.UnitPrice == ProductList.Min (P => P.UnitPrice)
////          select P.ProductName).FirstOrDefault();

////Console.WriteLine(Rst);

//Console.WriteLine(ProductList.Max (P=> P.UnitsInStock));

//Console.WriteLine(ProductList.Sum(P => P.UnitsInStock));

//Console.WriteLine(ProductList.Average (P => P.UnitsInStock));

#endregion

#region Generation Operators

//var Result = Enumerable.Range(0, 100);

//var DiscountedPrds = Enumerable.Empty<Product>();

//var Result = Enumerable.Repeat(false, 10).ToList();

//Result[0] = true;

//var Result = Enumerable.Repeat(ProductList.First(), 10).ToList();

//Result[0].ProductName = "TEST";


#endregion

#region Select Many 
///Enumerate each element in input Seq into Sub Seq in output Seq

//List<string> NameLst = new() { "Ahmed", "Ali", "Sally", "Fawzi", "Sayed", "Mai" };

//var Result = NameLst.SelectMany(N => N.ToCharArray());

/////Select Many in Query Syntax , use multiple from
//Result = (from N in NameLst
//         from C in N.ToCharArray()
//         orderby C
//         select C).Distinct();

//Result = NameLst.SelectMany(N => N.ToCharArray())
//            .OrderBy(C => C)
//            .Distinct();


#endregion

#region Set Operators

//var Lst1 = Enumerable.Range(0, 100);
//var Lst2 = Enumerable.Range(50, 100);


////var Result = Lst1.Concat(Lst2); ///Keep Duplicates

////Result = Lst1.Concat(Lst2).Distinct(); ///remove Duplicates

////Result = Lst1.Union(Lst2); ///remove Duplicates

//var PrdLst1 = ProductList.Take(10).ToList();
//List<Product> PrdLst2 = new() { new() { ProductID = 1 }, new() { ProductID = 2 }, new() { ProductID = 3 } };

////var Result02 = PrdLst1.Union(PrdLst2 , new ProductEqulityComparer());
////OR
////var Result02 = PrdLst1.UnionBy(PrdLst2, P => P.ProductID);

////foreach (var item in Result02)
////{
////    Console.WriteLine(item);
////}

//var Result = Lst1.Intersect(Lst2);

//Result = Lst1.Except(Lst2);



//foreach (var item in Result)
//{
//    Console.Write($"{item} , ");
//}
//Console.WriteLine();
#endregion

#region Quantifiers - return true\false

//Console.WriteLine(ProductList.Any()); //return true if at least on element exists in input seq

//Console.WriteLine(ProductList.Any( P => P.UnitsInStock ==0));
////return true if at least on element Match Predicate in input seq

//Console.WriteLine(ProductList.All(P => P.UnitsInStock > 0));
////return true if ALL elements in input Seq matching Predicate

#endregion

#region Let , Into 
List<string> NameLst = new() { "Ahmed", "Ali", "Sally", "Fawzi", "Sayed", "Mai" };

//var Result = from N in NameLst
//             select Regex.Replace(N, "[AOIEUaoieu]", string.Empty)
//             into NoVowl            ///Restart Query after select using New Range Variable 
//             where NoVowl.Length >= 3
//             orderby NoVowl descending
//             //select new { Orignal = N, NoVowl = NoVowl }; //Original Range Variable not Accessable
//             select NoVowl;

//Result = NameLst.Select(N => Regex.Replace(N, "[AOIEUaoieu]", string.Empty)).Where(NoVowl => NoVowl.Length >= 3)
//    .OrderByDescending (NoVowl => NoVowl);


//var Result = from N in NameLst
//             let NoVowl =  Regex.Replace(N, "[AOIEUaoieu]", string.Empty)
//             ///Intorduce new Range Variable in addition to Original
//             where NoVowl.Length >= 3
//             orderby NoVowl descending
//             select new { Orignal = N, NoVowl = NoVowl };

#endregion

#region Zip Operator

//int[] Arr = {1,2,3,4,5,6,7,8,9,10};
//List<string> NameLst = new() { "Ahmed", "Ali", "Sally", "Fawzi", "Sayed", "Mai" };

//var Result = Arr.Zip(NameLst, (i, N) => new { Id = i, Name = N }).OrderByDescending ( X => X.Name.Length);

#endregion

#region Group By
//var Result = from P in ProductList
//                 //where P.UnitsInStock >0
//             group P by P.Category;

var rslt = ProductList.GroupBy(P => P.Category);

//foreach (var PrdGroup   in Result)
//{
//    Console.WriteLine(PrdGroup.Key);

//    foreach (var Prd in PrdGroup)
//    {
//        Console.WriteLine($"..{Prd.ProductName}");
//    }
//}


var Result = from P in ProductList
             where P.UnitsInStock > 0
             group P by P.Category
             into PrdGroups 
             orderby PrdGroups.Count() descending
             select new { Category = PrdGroups.Key , PrdCount = PrdGroups.Count()};


#endregion

#region Casting Operators - Immediate Opeartors

//var Result = ProductList.ToList();
//var Result = ProductList.ToArray();

//var Result = ProductList.ToDictionary(P => P.ProductID);
///Dictionary <Long , Product> Dictionary <ProductID , Product>
//var Result = ProductList.ToDictionary(P=> P.ProductID , P=> new {P.ProductName , P.Category});
//Dictionary <Long , AnonymousType>

#endregion

foreach (var item in Result)
{
    Console.WriteLine(item);
}
